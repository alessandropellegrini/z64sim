options {
    JAVA_UNICODE_ESCAPE = true;
    ERROR_REPORTING = true;
    STATIC = false;
    JDK_VERSION = "1.7";
    BUILD_PARSER = true;
    IGNORE_CASE = true;
}



PARSER_BEGIN(Assembler)
package org.z64sim.assembler;
import java.io.StringReader;
import java.io.Reader;
import java.util.List;
import java.util.ArrayList;

public class Assembler {

    /** To support error recovery */
    public List<ParseException> syntaxErrors = new ArrayList<ParseException>();

    /**
     * A String-based constructor for ease of use
     *
     * @param s The program to be assembled
     */
    public Assembler(String s) {
        this((Reader)(new StringReader(s)));
    }

    /**
     * Error recovery function
     *
     * @param ex The exception keeping the parse error
     * @param kind The token to be reached so as to continue parsing
     */
    void error_recover(ParseException ex, int kind) {
        syntaxErrors.add(ex);
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != kind);
    }

}
PARSER_END(Assembler)


/*********
 * LEXER *
 *********/


/* No SKIP charachters: they are hidden to the Lexer interface, and
 * are rather needed for syntax highlighting. Might have an effect on performance
 * nevertheless...
 */
SPECIAL_TOKEN :
{ <WHITESPACE:
  " "
| "\t"
| "\f">
}

TOKEN :
{
<NEWLINE:
  "\n"
| "\r">
}

TOKEN :
{ 
  <COMMENT: ( "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n") ) |
            ( "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/") >
}


/** 
 * Regular tokens start here 
 */



/** Keywords */
TOKEN:
{ <LOCATION_COUNTER: ("." | ".org")>
| <DATA_SECTION: ".data">
| <CODE_SECTION: ".text">
| <BSS_SECTION: ".bss">
| <PROGRAM_END: ".end">
| <EQU_ASSIGN: ".equ">
| <BYTE_ASSIGN: ".byte">
| <WORD_ASSIGN: ".word">
| <LONG_ASSIGN: ".long">
| <QUAD_ASSIGN: ".quad">
| <ASCII_ASSIGN: ".ascii"> 
| <FILL_ASSIGN: ".fill">
| <COMM_ASSIGN: ".comm">
| <DRIVER: (".driver" | ".handler")>
}

/** Numeric/Arithmetic/Separator stuff */
TOKEN:
{ <SCALE: "1" | "2" | "4" | "8">
| <CONSTANT: "$"<NUMBER>>
| <NUMBER: <DEC> | <HEX>>
|   <#DEC: (["0"-"9"])+>
|   <#HEX: "0x"(["0"-"9","a"-"f"])+>
| <ASSIGN: "=">
| <PLUS: "+">
| <MINUS: "-">
| <TIMES: "*">
| <DIVIDE: "/">
| <LBRACE: "(">
| <RBRACE: ")">
| <COMMA: ",">
}

/** Registers */
TOKEN:
{ <REG_8: "%al" | "%cl" | "%dl" | "%bl">
| <REG_16: "%ax" | "%bx" | "%cx" | "%dx" | "%sp" | "%bp" | "%si" | "%di">
| <REG_32: "%eax" | "%ebx" | "%ecx" | "%edx" | "%esp" | "%ebp" | "%esi" | "%edi">
| <REG_64: "%rax" | "%rbx" | "%rcx" | "%rdx" | "%rsp" | "%rbp" | "%rsi" | "%rdi" | "%r8" | "%r9" | "%r10" | "%r11" | "%r12" | "%r13" | "%r14" | "%r15">
}

/** Instructions */
TOKEN:
{ <INSN_0: ( "movs" 
           | "stos" 
           | "in" 
           | "out" 
           | "ins" 
           | "outs")("b"|"w"|"l"|"q")?>
| <INSN_0_WQ: ("pushf" 
             | "popf" )("w"|"l"|"q")?>
| <INSN_0_NOSUFF:  "ret" 
                 | "iret"
                 | "clc" 
                 | "clp" 
                 | "clz" 
                 | "cls" 
                 | "cli" 
                 | "cld" 
                 | "clo" 
                 | "stc" 
                 | "stp"
                 | "stz" 
                 | "sts" 
                 | "sti"
                 | "std" 
                 | "sto" 
                 | "hlt" 
                 | "nop">
| <INSN_1_S: "int">
| <INSN_LEA: "lea"("b"|"w"|"l"|"q")?>   
| <INSN_1_E: ("push"
           | "pop"
           | "neg"
           | "not")("b"|"w"|"l"|"q")?>
| <INSN_SHIFT: ("sal"
            | "shl"
            | "sar"
            | "shr"
            | "rcl"
            | "rol"
            | "ror")("b"|"w"|"l"|"q")?>
| <INSN_1_M: ("jc"
            | "jp"
            | "jz"
            | "js"
            | "jo"
            | "jnc"
            | "jnp"
            | "jnz"
            | "jns"
            | "jno")>
| <INSN_JC: ("jmp"
           | "call")("b"|"w"|"l"|"q")?>
| <INSN_B_E: ("mov"
            | "add"
            | "sub"
            | "adc"
            | "sbb"
            | "cmp"
            | "test"
            | "and"
            | "or"
            | "xor")("b"|"w"|"l"|"q")?>
| <INSN_EXT: ("movs" | "movz")("bw"|"bl"|"bq"|"wl"|"wq"|"lq")>
| <INSN_IN: "in"("b"|"w"|"l"|"q")?>
| <INSN_OUT: "out"("b"|"w"|"l"|"q")?>
| <INSN_IO_S: ("ins"
           | "outs")("b"|"w"|"l")>
}

/** Text/Ascii stuff */
TOKEN:
{ <LABEL: ([".","_","-","a"-"z","0"-"9"])+ ":">
| <STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
}


TOKEN:
{
    /* Anything else is considered to be and error character.
     * Only one character must be matched because the (~[])+
     * would be the longest match so it would be always
     * preferred. The ERROR clause must be the last
     * in the grammar specification so that other one-char
     * clauses are matched preferably.
     * This is REQUIRED for correct online syntax highlighting,
     * but makes actual parsing a bit more difficult.
     */
    <ERROR: ~[] >
}






/****************
 * PARSER RULES *
 ****************/


void Program() :
{}
{ LocationCounter() <NEWLINE>
  ( Statement() )+
  <PROGRAM_END>
  (<NEWLINE>)* /* This is to consume newlines at the end of file */
  <EOF>
}

void Statement() :
{}
{
  Label() <NEWLINE> 
| Instruction() <NEWLINE> 
| <NEWLINE>
}

void LocationCounter() :
{}
{ 
    try {

        /* ACTUAL RULE */
        <LOCATION_COUNTER> <NUMBER>

    } catch (ParseException ex) {
        error_recover(ex, NEWLINE);
    }
}


void Instruction() :
{}
{
    try {

        /* ACTUAL RULE */
        <INSN_0>
      | <INSN_0_WQ>
      | <INSN_0_NOSUFF>
      | <INSN_1_S> <NUMBER>
      | <INSN_1_E> FormatE()
      | <INSN_SHIFT> ( FormatK() <COMMA> )? FormatG()
      | <INSN_1_M> FormatM()
      | <INSN_JC> ( FormatM() | <TIMES> FormatG() )
      | <INSN_B_E> FormatB() <COMMA> FormatE()
      | <INSN_EXT> FormatE() <COMMA> FormatG()
      | <INSN_IN> <REG_16> <COMMA> (<REG_8> | <REG_16> | <REG_32> | <REG_64>) /* programmatically check for registers */
      | <INSN_OUT> (<REG_8> | <REG_16> | <REG_32> | <REG_64>) <COMMA> <REG_16> /* programmatically check for registers */
      | <INSN_IO_S>

    } catch (ParseException ex) {
        error_recover(ex, NEWLINE);
    }
}




void Label() :
{}
{ 
    try {

        /* ACTUAL RULE */
        <LABEL> 

    } catch (ParseException ex) {
        error_recover(ex, NEWLINE);
    }
}



void Register() :
{}
{
    try {

        /* ACTUAL RULE */
        <REG_8> | <REG_16> | <REG_32> | <REG_64>

    } catch (ParseException ex) {
        error_recover(ex, NEWLINE);
    }
}


void Addressing() :
{}
{ 
    try {

        /* ACTUAL RULE */
        ( <CONSTANT> /* | <LABEL> */ )?
        ( <LBRACE>
         (<REG_8> | <REG_16> | <REG_32> | <REG_64>)
         "," 
         (<REG_8> | <REG_16> | <REG_32> | <REG_64>) "," <SCALE>
        <RBRACE> )?

    } catch (ParseException ex) {
        error_recover(ex, NEWLINE);
    }
}


void FormatE() :
{}
{ 
    try {

        /* ACTUAL RULE */
        Register() | <CONSTANT> | Addressing()

    } catch (ParseException ex) {
        error_recover(ex, NEWLINE);
    }
}



void FormatK() :
{}
{ 
    try {

        /* ACTUAL RULE */
        "@"

    } catch (ParseException ex) {
        error_recover(ex, NEWLINE);
    }
}



void FormatG() :
{}
{
    try {

        /* ACTUAL RULE */
        "@"

    } catch (ParseException ex) {
        error_recover(ex, NEWLINE);
    }
}


/* Both label and direct address */
void FormatM() : 
{}
{
    try {

        /* ACTUAL RULE */
        "@"

    } catch (ParseException ex) {
        error_recover(ex, NEWLINE);
    }
}



void FormatB() :
{}
{
    try {

        /* ACTUAL RULE */
        "@"

    } catch (ParseException ex) {
        error_recover(ex, NEWLINE);
    }
}
